import logging
log = logging.getLogger(__name__)
import enum
from functools import partial

from atom.api import Bool, Int, Typed, Value
from enaml.core.api import Conditional
from enaml.application import deferred_call
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command


from psi.controller.api import (ControllerManifest, ControllerPlugin,
                                ExperimentEvent,
                                ExperimentState)

from psi.util import rpc


class TrialState(enum.Enum):
    pass


def process_et(event):
    plugin = event.workbench.get_plugin('psi.controller')
    name = event.parameters['name']
    events = event.parameters['data'].events
    for _, (edge, ts) in events[['event', 'ts']].iterrows():
        plugin.et_callback(name, edge, ts)



################################################################################
# Base controllers
################################################################################
class BaseBehaviorPlugin(ControllerPlugin):

    #: Must define event_map as an attribute on the subclass. Keys will be a
    #: tuple of (edge, event_type) where edge is either 'rising' or 'falling'
    #: and event_type indicates the type of event (e.g., reward contact). The
    #: key ('rising', 'reward_contact') indicates that a rising edge was
    #: detected on the 'reward_contact' input, indicating that the animal has
    #: begun attempting ot retrive a reward. See `handle_event`.
    event_map = {}

    #: Has a remind trial been requested?
    _remind_requested = Bool(False)

    #: Info about the trial that will get saved to the trial log
    trial_info = Typed(dict, ())

    #: Current state of the trial (see BaseGoNogoTrialState for some possible
    #: states).
    trial_state = Typed(TrialState)

    def can_modify(self):
        return True

    def pause_experiment(self):
        if self.can_modify():
            self.experiment_state = 'paused'
            self._pause_requested = False
            self.invoke_actions('experiment_paused', self.get_ts())
            return True
        return False

    def resume_experiment(self):
        if self.can_modify():
            self.experiment_state = 'running'
            self._resume_requested = False
            self.invoke_actions('experiment_resumed', self.get_ts())
            self.prepare_trial()
            return True
        return False

    def apply_changes(self):
        if self.can_modify():
            log.info('Applying changes')
            self.context.apply_changes()
            self.context.next_setting()
            self.prepare_trial()
            self._apply_requested = False
            return True
        return False

    def request_remind(self):
        self._remind_requested = True
        if self.can_modify():
            self.prepare_trial(auto_start=True)

    def et_callback(self, name, edge, event_time):
        #log.debug('Detected {} on {} at {}'.format(edge, name, event_time))
        event = self.event_map[edge, name]
        self.handle_event(event, event_time)

    def handle_event(self, event, timestamp=None):
        '''
        Given the current experiment state, process the appropriate response
        for the event that occured. Depending on the experiment state, a
        particular event may not be processed.
        '''
        # Only events generated by engine callbacks will have a timestamp.
        # Since we want all timing information to be in units of the analog
        # output sample clock, we will capture the value of the sample clock if
        # a timestamp is not provided. Since there will be some delay between
        # the time the event occurs and the time we read the analog clock, the
        # timestamp won't be super-accurate. However, it's not super-important
        # since these events are not reference points around which we would do
        # a perievent analysis. Important reference points would include
        # nose-poke initiation and withdraw, reward contact, sound onset,
        # lights on, lights off. These reference points will be tracked via
        # NI-DAQmx or can be calculated (i.e., we know exactly when the target
        # onset occurs because we precisely specify the location of the target
        # in the analog output buffer).
        if timestamp is None:
            timestamp = self.get_ts()

        # May need to wrap this in a lock, but let's hold off and see if this
        # is needed.
        self.invoke_actions(event.name, timestamp)
        if self.experiment_state == 'paused':
            # If the experiment is paused, don't do anything.
            return
        getattr(self, f'handle_{self.trial_state.name}')(event, timestamp)

    def start_event_timer(self, duration, event):
        # We call the timer `experiment_state` to ensure that it properly ends
        # any existing event-based timers.
        if isinstance(duration, str):
            duration = self.context.get_value(duration)
        log.info('Timer for {} with duration {}'.format(event, duration))
        callback = partial(self.handle_event, event)
        self.start_timer('event', duration, callback, cancel_existing=True)

    def stop_event_timer(self):
        self.stop_timer('event')
